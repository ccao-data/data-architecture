---
title: "Test of geocoding"
format: 
  html:
    self_contained: true
    embed-resources: true
    warning: false
    echo: false
---

## Problem Statement:

Between 2015 and our current datset there are 15676 missing geographies. We are attempting to geocode these geographies, using two different methods.

## Technique 1:
If a value for x and y is present for the proceeding and following year & both those values are within .0001 of eachother, we use the average of those two values. (imputed)

## Technique 2:
We geocode the addresses from openstreet maps. (geocoding)


```{r}
library(DBI)
library(dplyr)
library(ggplot2)
library(leaflet)
library(noctua)
library(purrr)
library(RColorBrewer)
library(readr)
library(sf)
library(tidyr)
library(tidygeocoder)
con <- dbConnect(noctua::athena())

missing_geographies <- dbGetQuery(
  conn = con,
  "select distinct vpa.year,
        vpa.prop_address_full,
        vpa.prop_address_city_name,
        vpa.prop_address_state,
        vpa.prop_address_zipcode_1,
        vpu.pin,
        vpu.pin10,
        vpu.x_3435,
        vpu.y_3435,
        vpu.lon,
        vpu.lat
 from default.vw_pin_address vpa
 left join default.vw_pin_universe vpu
   on vpa.pin = vpu.pin and vpa.year = vpu.year
 where vpa.year >= '2000'
   and vpa.pin in (
       select distinct pin
       from default.vw_pin_universe
       where year >= '2000'
         and (x_3435 is null or y_3435 is null)
     )"
)

# We impute geographies based on a matching address and pin10
# This is forward-backward filled, meaning that if the information
# is missing for 2015, it pulls 2016 then 2014, 2017, etc.
missing_geographies_imputed <- missing_geographies %>%
  mutate(
    missing = is.na(x_3435) | is.na(y_3435),
    x_3435_imputed = x_3435,
    y_3435_imputed = y_3435,
    lon_imputed = lon,
    lat_imputed = lat
  ) %>%
  group_by(prop_address_full, pin10) %>%
  arrange(year) %>%
  fill(x_3435_imputed, y_3435_imputed, lon_imputed,
    lat_imputed,
    .direction = "updown"
  ) %>%
  ungroup() %>%
  distinct(pin10, year, .keep_all = TRUE) %>%
  filter(is.na(x_3435) | is.na(y_3435)) %>%
  select(c(
    "year", "pin10", "x_3435_imputed", "y_3435_imputed",
    "lon_imputed", "lat_imputed", "prop_address_full"
  ))

# This filters out all missing geography features,
# removing the years which we use to impute
# the missing values in step 1.
missing_geographies <- missing_geographies %>%
  filter(is.na(x_3435) | is.na(y_3435)) %>%
  distinct(pin, year, .keep_all = TRUE) %>%
  # removes missing columns since geocoding duplicates lat
  select(-c("x_3435", "y_3435", "lon", "lat"))

# Split the missing coordinates into batches of 1000 rows for tidygeocoder
batch_list <- split(
  missing_geographies,
  ceiling(seq_len(nrow(missing_geographies)) / 1000)
)
cook_county <- dbGetQuery(
  conn = con,
  "select *
 from spatial.county"
) %>%
  st_as_sf() %>%
  st_set_crs(3435)


# Function to geocode each batch
geocode_batch <- function(batch) {
  batch %>%
    geocode(
      street = prop_address_full,
      city   = prop_address_city_name,
      state  = prop_address_state,
      method = "census"
    ) %>%
    filter(!is.na(long) & !is.na(lat)) %>%
    st_as_sf(coords = c("long", "lat"), remove = FALSE) %>%
    st_set_crs(4326) %>%
    st_transform(3435) %>%
    # One known property is outside of Cook County
    st_join(cook_county) %>%
    mutate(
      x_3435 = st_coordinates(.)[, 1],
      y_3435 = st_coordinates(.)[, 2]
    )
}

# Apply geocoding to each batch and combine results
geocoded_data <- map(batch_list, geocode_batch) %>%
  do.call(rbind, .)

# Addresses are on PIN level, so we create the PIN10 average
# This is mostly for complexes
geocoded_data <- geocoded_data %>%
  group_by(pin10, year) %>%
  summarise(
    avg_lon_geocoded = mean(long, na.rm = TRUE),
    avg_lat_geocoded = mean(lat, na.rm = TRUE),
    avg_x_3435_geocoded = mean(x_3435, na.rm = TRUE),
    avg_y_3435_geocoded = mean(y_3435, na.rm = TRUE),
    prop_address_full = first(prop_address_full)
  ) %>%
  ungroup() %>%
  select(-geometry)
```


```{r}
# This isn't used for the QC doc, but is what we have in the script

# Join the geocoded and imputed datasets
final <- full_join(missing_geographies_imputed,
  geocoded_data,
  by = c("pin10", "year")
) %>%
  select(
    pin10, year, avg_lon_geocoded, avg_lat_geocoded,
    avg_x_3435_geocoded, avg_y_3435_geocoded,
    x_3435_imputed, y_3435_imputed, lon_imputed, lat_imputed
  )

final <- final %>%
  mutate(
    # Calculate Euclidean distance using the projected coordinates
    distance = sqrt((x_3435_imputed - avg_x_3435_geocoded)^2 +
      (y_3435_imputed - avg_y_3435_geocoded)^2),

    # Replace x_3435 with the imputed value if both available
    # and within 100 feet, else choose available value or NA
    x_3435 = if_else(
      !is.na(x_3435_imputed) & !is.na(avg_x_3435_geocoded),
      if_else(distance <= 1000, x_3435_imputed, NA_real_),
      coalesce(x_3435_imputed, avg_x_3435_geocoded)
    ),

    # Replace y_3435 with the imputed value if both available
    # and within 100 feet, else choose available value or NA
    y_3435 = if_else(
      !is.na(y_3435_imputed) & !is.na(avg_y_3435_geocoded),
      if_else(distance <= 1000, y_3435_imputed, NA_real_),
      coalesce(y_3435_imputed, avg_y_3435_geocoded)
    ),

    # Create lon using lon_imputed and lon_geocoded; if both
    # exist and distance is within threshold, choose imputed;
    # otherwise use available value or NA
    lon = if_else(
      !is.na(lon_imputed) & !is.na(avg_lon_geocoded),
      if_else(distance <= 1000, lon_imputed, NA_real_),
      coalesce(lon_imputed, avg_lon_geocoded)
    ),

    # Create lat using lat_imputed and lat_geocoded with similar logic
    lat = if_else(
      !is.na(lat_imputed) & !is.na(avg_lat_geocoded),
      if_else(distance <= 1000, lat_imputed, NA_real_),
      coalesce(lat_imputed, avg_lat_geocoded)
    ),
    source = if_else(
      !is.na(x_3435_imputed) & !is.na(avg_x_3435_geocoded),
      if_else(distance <= 1000, "imputed", "none"),
      if_else(!is.na(x_3435_imputed), "imputed",
        if_else(!is.na(avg_x_3435_geocoded), "geocoded", "none")
      )
    )
  ) %>%
  select(pin10, year, x_3435, y_3435, lon, lat, source) %>%
  filter(!is.na(x_3435) & !is.na(y_3435) & !is.na(lon) & !is.na(lat))
```

## Results:

The number of PIN10 geographies filled by imputing is `r nrow(missing_geographies_imputed)` and the number of geographies filled by geocoding is `r nrow(geocoded_data)`.

## Imputed PINs:

```{r}
geocoded_data <- geocoded_data %>%
  st_as_sf(
    coords = c("avg_lon_geocoded", "avg_lat_geocoded"),
    remove = FALSE
  ) %>%
  st_transform(crs = 4326) %>%
  st_cast("POINT")

missing_geographies_imputed <- missing_geographies_imputed %>%
  filter(!is.na(lon_imputed)) %>%
  st_as_sf(coords = c("lon_imputed", "lat_imputed"), crs = 4326)


imputed_map <- leaflet(data = subset(missing_geographies_imputed)) %>%
  addTiles() %>%
  addCircleMarkers(
    popup = ~ paste(
      "<strong>Address:</strong>", prop_address_full, "<br>",
      "<strong>PIN10:</strong>", pin10, "<br>",
      "<strong>Year:</strong>", year
    ),
    clusterOptions = markerClusterOptions()
  )

imputed_map
```

## Geocoded PINs:

```{r}
geocoded_data <- geocoded_data %>%
  st_as_sf(
    coords = c("avg_lon_geocoded", "avg_lat_geocoded"),
    remove = FALSE, crs = 4326
  ) %>%
  st_cast("POINT") # Ensure geometry is of type POINT

geocoded_map <- leaflet(data = geocoded_data) %>%
  addTiles() %>%
  addCircleMarkers(
    popup = ~ paste(
      "<strong>Address:</strong>", prop_address_full, "<br>",
      "<strong>PIN10:</strong>", pin10, "<br>",
      "<strong>Year:</strong>", year
    ),
    clusterOptions = markerClusterOptions()
  )

geocoded_map
```


```{r}
combined_geographies <- bind_rows(
  missing_geographies_imputed,
  geocoded_data
) %>%
  st_cast("POINT") %>%
  st_transform(crs = 4326) %>%
  st_set_crs(4326) %>%
  mutate(
    technique = if_else(!is.na(x_3435_imputed), "imputed", "geocoded")
  )

combined_geographies <- combined_geographies %>%
  group_by(pin10, year) %>%
  filter(n() == 2, all(c("imputed", "geocoded") %in% technique)) %>%
  mutate(
    distance_ft = as.numeric(
      st_distance(
        geometry[technique == "imputed"],
        geometry[technique == "geocoded"]
      )
    )
    * 3.28084
  ) %>%
  ungroup()
```

## Map of all PINs with results from both techniques:
To test how these work, we join them back together again and create a distance in ft collumn. This is the difference between observations with both imputed and geocoded techniques. The result shows that both techniques are very similar, although there are some differences.

```{r}
pal <- colorFactor(
  palette = c("red", "blue"),
  domain = combined_geographies$technique
)

leaflet(data = combined_geographies) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~ pal(technique),
    popup = ~ paste(
      "<strong>Technique:</strong>", technique, "<br>",
      "<strong>Address:</strong>", prop_address_full
    )
  )
```

## Pins with Long Distances ( > 1000 ft):

```{r}
subset <- combined_geographies %>%
  mutate(distance_ft = as.numeric(distance_ft)) %>%
  filter(distance_ft > 1000)

subset_post_2015 <- combined_geographies %>%
  filter(year >= 2015)
```


There are `r nrow(subset)` matched geographies over 1,000 ft apart out of `r nrow(combined_geographies)`. Of these, only `r nrow(subset_post_2015)` are from 2015 or later.

The main (fixable) issue that I saw here was that directions of streets were not correct (359 W Ohio is likely 359 E Ohio).
```{r}
leaflet(data = subset) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~ pal(technique),
    popup = ~ paste(
      "<strong>PIN10:</strong>", pin10, "<br>",
      "<strong>Technique:</strong>", technique, "<br>",
      "<strong>Address:</strong>", prop_address_full, "<br>",
      "<strong>year:</strong>", year, "<br>",
      ifelse(!is.na(distance_ft),
        paste("<strong>Distance (ft):</strong>", round(distance_ft, 2)),
        ""
      )
    )
  )
```
## Data post 2015
```{r}
leaflet(data = subset_post_2015) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~ pal(technique),
    popup = ~ paste(
      "<strong>PIN10:</strong>", pin10, "<br>",
      "<strong>Technique:</strong>", technique, "<br>",
      "<strong>Address:</strong>", prop_address_full, "<br>",
      "<strong>year:</strong>", year, "<br>",
      ifelse(!is.na(distance_ft),
        paste("<strong>Distance (ft):</strong>", round(distance_ft, 2)),
        ""
      )
    )
  )
```

## Example of large parcel pin

The biggest issue were pins like this, which are on very large parcels. I'm still doing some QC on them, but this is a pretty expected outcome between the two techniques, where geocoding seems to put a parcel directly on the street, and imputing in the center of the pin. 
```{r}
subset_a <- subset %>%
  filter(pin10 == "0609200026")

leaflet(data = subset_a) %>%
  addTiles() %>%
  addCircleMarkers(
    color = ~ pal(technique),
    popup = ~ paste(
      "<strong>PIN10:</strong>", pin10, "<br>",
      "<strong>Technique:</strong>", technique, "<br>",
      "<strong>Address:</strong>", prop_address_full, "<br>",
      ifelse(!is.na(distance_ft),
        paste("<strong>Distance (ft):</strong>", round(distance_ft, 2)),
        ""
      )
    )
  )
```

## Histogram of Distance (ft) Between Techniques

The vast majority of pins are within 300 feet of eachother. An example of this would be Address: 1346 W CULLERTON ST 3 CHICAGO IL 60608, CHICAGO, IL. These are 185 feet apart, and three houses apart. While not ideal, it definetely seems to be an improvement over no information. The selection of 5,000 ft difference was largely arbitrary, but shows that data seems pretty consistent.

What this does not answer is if PINs which have only one one technique are harder to code (weirder addresses). There is no intuitive reason why this would be the case, but it is something we should think about. 

```{r}
distance_by_group <- combined_geographies %>%
  distinct(pin10, year, .keep_all = TRUE) %>%
  mutate(distance_ft = as.numeric(as.character(distance_ft))) %>%
  filter(distance_ft < 5000)

p <- ggplot(distance_by_group, aes(x = distance_ft)) +
  geom_histogram(binwidth = 100, fill = "steelblue", color = "white") +
  labs(
    title = "Histogram of Distance (ft) Between Techniques",
    x = "Distance (ft)",
    y = "Frequency"
  ) +
  theme_minimal()

print(p)
```

# Conclusion:

In general, the two techniques produce similar results. I'd have to go through them a bit more in depth, but at the moment, the geocoding looks a bit better, specifically because it fills more observations. On the other hand, the imputed values are more likely to be correct, as we know we have some issues with our address data. 

