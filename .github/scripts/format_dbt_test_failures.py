#!/usr/bin/env python3
#
# Generates an.Excel workbook of dbt test failures that can be shared with
# other teams for review and correction.
#
# This script assumes that it is being run in sequence after a call to
# `dbt test --store-failures`, since it depends on two files created by
# that operation (target/run_results.json and target/manifest.json).
# It also requires Python dependencies be installed from
# format_dbt_test_failures_requirements.txt.
#
# Accepts three optional positional arguments:
#
#   1. The local path to a run_results.json file generated by a test run
#     * If not present, defaults to './target/run_results.json'
#   2. The local path to a manifest.json file with the compiled dbt DAG
#     * If not present, defaults to './target/manifest.json'
#   3. The output filepath to which the workbook should be written
#     * If not present, defaults to './qc_test_failures_<date>.xlsx'
#
# Expects one environment variable to be set:
#
#  1.AWS_ATHENA_S3_STAGING_DIR: Location in S3 where Athena query results
#    should be written. If missing, defaults to the
#    ccao-athena-results-us-east-1 bucket
#
# Each sheet in the output workbook represents a category of test, e.g.
# "valid_range" or "not_null"; each row in a sheet represents a row in a
# database that failed a test, with enough metadata that a reader can
# figure out what conditions caused the test to fail and investigate the
# root cause.
#
# Example usage:
#
#   AWS_ATHENA_S3_STAGING_DIR=s3://foo-bar-baz/ \
#       python3 format_dbt_test_failures.py \
#       ./target/run_results.json \
#       ./target/manifest.json \
#       ./qc_test_failures.xlsx

import dataclasses
import datetime
import json
import os
import sys
import typing

import openpyxl
import openpyxl.styles
import pyathena
import pyathena.cursor
from openpyxl.worksheet.worksheet import Worksheet

DEFAULT_TEST_CATEGORY = "miscellaneous"
AWS_ATHENA_S3_STAGING_DIR = os.getenv(
    "AWS_ATHENA_S3_STAGING_DIR",
    "s3://ccao-athena-results-us-east-1/"
)

@dataclasses.dataclass
class FailedTestGroup:
    """Class to store query results for a group of failed dbt tests and provide
    convenience methods for formatting those results for output to a report."""
    def __init__(self) -> None:
        self._rows: typing.List[typing.Dict] = []

    def update(self, new_rows: typing.List[typing.Dict]) -> None:
        """Add a list of new_rows to the rows of failing tests tracked by
        this group. The new_rows list should be formatted like the rows
        returned by a csv.DictReader or a DictCursor, i.e. a list of
        dicts mapping `{column_name: row_value}`."""
        self._rows = [*self._rows, *new_rows]

    @property
    def fieldnames(self) -> typing.List[str]:
        """Get a list of fieldnames that encapsulates all of the fieldnames
        for all of the rows of failing tests tracked by this group."""
        fieldnames = []
        for row in self._rows:
            for column in row.keys():
                if column not in fieldnames:
                    fieldnames.append(column)
        return fieldnames

    @property
    def rows(self) -> typing.List[typing.List]:
        """Format the rows of failing tests tracked by this group, with
        fieldname data excluded. The combination of this property and the
        `fieldnames` property can be used to write to a csv.Writer or
        to an openpyxl.Workbook sheet for the tests tracked by this group."""
        fieldnames = self.fieldnames
        return [
            [row.get(fieldname) for fieldname in fieldnames]
            for row in self._rows
        ]


# Struct representing a mapping of sheet names to the tests contained therein
FailedTestsByCategory = typing.Dict[str, FailedTestGroup]


def main() -> None:
    """Entrypoint to this script. Parses input arguments and writes a zipfile
    of test failures to the output path."""
    try:
        run_results_filepath = sys.argv[1]
    except IndexError:
        run_results_filepath = os.path.join("target", "run_results.json")

    try:
        manifest_filepath = sys.argv[2]
    except IndexError:
        manifest_filepath = os.path.join("target", "manifest.json")

    try:
        output_filepath = sys.argv[3]
    except IndexError:
        date_today = datetime.datetime.today().strftime("%Y-%m-%d")
        output_filepath = f"qc_test_failures_{date_today}.xlsx"

    with open(run_results_filepath) as run_results_fobj:
        run_results = json.load(run_results_fobj)

    with open(manifest_filepath) as manifest_fobj:
        manifest = json.load(manifest_fobj)

    failed_tests_by_category = get_failed_tests_by_category(
        run_results, manifest
    )
    if not failed_tests_by_category:
        raise ValueError(f"{run_results_filepath} contains no failed rows")

    workbook = openpyxl.Workbook()
    for sheet_name, failed_test_group in failed_tests_by_category.items():
        add_sheet_to_workbook(workbook, sheet_name, failed_test_group)
    workbook.save(output_filepath)


def get_failed_tests_by_category(
    run_results: typing.Dict, manifest: typing.Dict
) -> FailedTestsByCategory:
    """Given two artifacts from a `dbt test --store-failures` call (a
    run_results.json file dict and a manifest.json file dict), generates a dict
    where each key is a name of a sheet and each associated value is
    a list of failed tests for that sheet."""
    conn = pyathena.connect(
        s3_staging_dir=AWS_ATHENA_S3_STAGING_DIR,
        region_name="us-east-1",
        cursor_class=pyathena.cursor.DictCursor,
    )
    cursor = conn.cursor()

    failed_tests_by_category: FailedTestsByCategory = {}

    for result in run_results["results"]:
        if result["status"] == "fail":
            unique_id = result["unique_id"]
            # Unique ID format is:
            # test.athena.<test_name>.<hash>
            test_name = unique_id.split(".")[2]

            node = manifest["nodes"].get(unique_id)
            if node is None:
                raise ValueError(
                    f"Missing dbt manifest node with id {unique_id}"
                )

            meta = node.get("meta", {})
            category = meta.get("category", DEFAULT_TEST_CATEGORY)
            test_description = meta.get("description")

            # Search for the model that is implicated in this test via the
            # depends_on key
            models = node.get("depends_on", {}).get("nodes", [])
            if not models:
                raise ValueError(
                    f"Missing `depends_on.nodes` attribute for test {test_name}"
                )
            # Cross-table comparisons often involve multiple models; we have
            # determined experimentally that the second one is usually
            # the model that the test is concerned with, although if this
            # becomes a problem in the future we can update the test metadata
            # to expose an override attribute
            model = models[-1]

            # Reference format for models/sources is:
            # <"model"/"source">.athena.<schema_name>.<table_name>
            table_name = model.split(".")[-1]

            # Get the fully-qualified name of the table that stores failures
            # for this test so that we can query it
            test_results_relation_name = node.get("relation_name")
            if test_results_relation_name is None:
                raise ValueError(
                    f"Missing relation_name attribute for test {test_name}. "
                    "Did you run `dbt test` with the --store-failures flag?"
                )

            print(f"Querying failed rows from {test_results_relation_name}")
            cursor.execute(f"select * from {test_results_relation_name}")
            query_results = cursor.fetchall()
            if len(query_results) == 0:
                raise ValueError(
                    f"Test {test_name} has status 'fail' but no failures"
                )

            # Add custom fields to query results that we don't expect to be
            # included in the response
            failed_tests = [
                {
                    "iasworld_table": table_name,
                    "description": test_description,
                    **row,
                }
                for row in query_results
            ]

            if not failed_tests_by_category.get(category):
                failed_tests_by_category[category] = FailedTestGroup()
            failed_tests_by_category[category].update(failed_tests)

    return failed_tests_by_category


def add_sheet_to_workbook(
    workbook: openpyxl.Workbook,
    sheet_title: str,
    failed_test_group: FailedTestGroup,
) -> None:
    """Add a sheet of failed dbt tests to an openpyxl Workbook."""
    # openpyxl Workbooks are created with one untitled active sheet by
    # default, so rename and fill out that sheet before creating any
    # new sheets
    sheet: Worksheet
    if workbook.sheetnames == ["Sheet"]:
        sheet = workbook.active
    else:
        sheet = workbook.create_sheet()

    sheet.title = sheet_title

    # Style the header differently from rows so that it is visually
    # distinct
    sheet.append(failed_test_group.fieldnames)
    font = openpyxl.styles.Font(bold=True)
    for cell in sheet[1]:
        cell.font = font

    for row in failed_test_group.rows:
        sheet.append(row)


if __name__ == "__main__":
    main()
