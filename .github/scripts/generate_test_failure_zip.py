#!/usr/bin/env python3
#
# Generates a .zip file containing Excel workbooks of dbt test failures that
# can be shared with other teams for human review.
#
# This script assumes that it is being run in sequence after a call to
# `dbt test --store-failures`, since it depends on two files created by
# that operation (target/run_results.json and target/manifest.json).
#
# Expects three optional positional arguments:
#
#   1. The local path to the run_results.json file generated by a test run
#     i. If not present, defaults to './target/run_results.json'
#   2. The local path to the manifest.json file for the dbt DAG
#     i. If not present, defaults to './target/manifest.json'
#   3. The output path to write the .zip file
#     i. If this argument is missing, the script will default to
#        './test_failures.zip'
#
# Expects one environment variable to be set:
#
#  1.AWS_ATHENA_S3_STAGING_DIR: Location in S3 where Athena query results
#    should be written
#
# Each workbook in the output .zip file represents a view or table in the
# warehouse; each sheet in a workbook represents a failed test; and each row
# in a sheet represents a database row that failed. The resulting directory
# structure looks like this:
#
#   <output_path>/
#         |
#         --- <schema1>/
#         |      |
#         |      --- <view/table1>.xslx
#         |      |
#         |      --- <view/table2>.xlsx
#         |
#         --- <schema2>/
#                |
#                --- <view/table3>.xlsx
#
# Example usage:
#
#   AWS_ATHENA_S3_STAGING_DIR=s3://foo-bar-baz/ \
#       python3 generate_test_failure_workbook_zip.py \
#       ./target/run_results.json \
#       ./target/manifest.json \
#       ./test_failures.zip

import dataclasses
import json
import os
import random
import shutil
import sys
import typing

import openpyxl
import openpyxl.styles
import pyathena


@dataclasses.dataclass
class FailedTest:
    """Struct representing a failed dbt test."""

    name: str
    display_name: typing.Optional[str]
    description: typing.Optional[str]
    fieldnames: typing.List
    failed_rows: typing.Tuple


FailedTestsByModel = typing.Dict[str, typing.List[FailedTest]]


class FailedTestWorkbook:
    """Wrapper around openpyxl.Workbook providing convenience methods
    for producing a workbook of failed dbt tests."""

    def __init__(self, model_name: str) -> None:
        # The name of the dbt model for which this workbook is storing
        # test failures
        self.model_name = model_name
        self._workbook = openpyxl.Workbook()
        # Keep track of sheet names to avoid collisions, since some sheet
        # names are autogenerated based on the unique ID of the test
        self._sheet_name_cache = set()

    def add_sheet(self, failed_test: FailedTest) -> None:
        """Add a failed dbt test to the workbook in the form of a new
        sheet."""
        # openpyxl workbooks are created with one untitled active sheet by
        # default, so rename and fill out that sheet before creating any
        # new sheets
        if self._workbook.sheetnames == ["Sheet"]:
            sheet = self._workbook.active
        else:
            sheet = self._workbook.create_sheet()

        # `display_name` can be null, so fall back to `name`
        test_name = failed_test.display_name or failed_test.name
        self._set_sheet_title(sheet, test_name)

        # We are rolling out test descriptions incrementally, so only add a
        # description row if a description is defined on the test
        header_idx = 1
        if failed_test.description is not None:
            sheet.append([failed_test.description])
            header_idx = 2

        # Style the header differently from rows so that it is visually
        # distinct
        sheet.append(failed_test.fieldnames)
        font = openpyxl.styles.Font(bold=True)
        for cell in sheet[header_idx]:
            cell.font = font

        for failed_row in failed_test.failed_rows:
            sheet.append(failed_row)

    def _set_sheet_title(
        self, sheet: openpyxl.worksheet.worksheet.Worksheet, test_name: str
    ) -> None:
        # For maximum compatibility, Excel worksheet names should not exceed
        # 31 characters
        title = test_name[:31]
        # Some tests have identical names when truncated, so check the cache
        # to see if we need to alter this name to make it unique
        while title in self._sheet_name_cache:
            # For now, assume that allocating 100 slots will be enough to
            # ensure there are no collisions for a given truncated name
            title = f"{test_name[:29]}{random.randint(0, 99):02d}"
        self._sheet_name_cache.add(title)
        sheet.title = title

    def save(self, output_dirpath: str) -> None:
        """Save the workbook to a file in the `output_dirpath` directory
        with a filename autogenerated based on the name of the model."""
        # The format for model identifiers is
        # <'source'/'model'>.athena.<schema_name>.<model_name>
        workbook_filename = f"{self.model_name.split('athena.')[-1]}.xlsx"
        self._workbook.save(os.path.join(output_dirpath, workbook_filename))


def main() -> None:
    """Entrypoint to this script. Parses input arguments and writes a zipfile
    of test failures to the output path."""
    try:
        run_results_filepath = sys.argv[1]
    except IndexError:
        run_results_filepath = os.path.join("target", "run_results.json")

    try:
        manifest_filepath = sys.argv[2]
    except IndexError:
        manifest_filepath = os.path.join("target", "manifest.json")

    try:
        output_filepath = sys.argv[3]
    except IndexError:
        output_filepath = "test_failures.zip"

    with open(run_results_filepath) as run_results_fobj:
        run_results = json.load(run_results_fobj)

    with open(manifest_filepath) as manifest_fobj:
        manifest = json.load(manifest_fobj)

    failed_tests_by_model = get_failed_tests_by_model(run_results, manifest)
    if not failed_tests_by_model:
        raise ValueError(f"{run_results_filepath} contains no failed rows")

    write_output_file(output_filepath, failed_tests_by_model)


def get_failed_tests_by_model(
    run_results: typing.Dict, manifest: typing.Dict
) -> FailedTestsByModel:
    """Given two artifacts from a `dbt test --store-failures` call (a
    run_results.json file and a manifest.json file), generates a dict
    where each key is a model in the warehouse and each associated value is
    a list of failed tests for that model."""
    conn = pyathena.connect(
        s3_staging_dir=os.getenv("AWS_ATHENA_S3_STAGING_DIR"),
        region_name="us-east-1",
    )
    cursor = conn.cursor()

    failed_tests_by_model: FailedTestsByModel = {}

    for result in run_results["results"]:
        if result["status"] == "fail":
            unique_id = result["unique_id"]
            # Unique ID format is:
            # test.athena.<name>.<hash>
            name = unique_id.split(".")[2]

            node = manifest["nodes"].get(unique_id)
            if node is None:
                raise ValueError(
                    f"Missing dbt manifest node with id {unique_id}"
                )

            meta = node.get("meta", {})
            display_name = meta.get("display_name")
            description = meta.get("description")

            models = node.get("depends_on", {}).get("nodes", [])
            if not models:
                breakpoint()
                raise ValueError(
                    f"Missing depends_on.nodes attribute for test {name}"
                )
            model = models[0]

            relation_name = node.get("relation_name")
            if relation_name is None:
                raise ValueError(
                    f"Missing relation_name attribute for test {name}. "
                    "Did you run `dbt test` with the --store-failures flag?"
                )

            print(f"Querying failed rows from {relation_name}")
            cursor.execute(f"select * from {relation_name}")
            # The first element of each tuple in the list produced by
            # cursor.description is always the column name
            fieldnames = [col_meta[0] for col_meta in cursor.description]
            failed_rows = cursor.fetchall()
            if len(failed_rows) == 0:
                raise ValueError(
                    f"Test {relation_name} has status 'fail' but no failures"
                )

            if not failed_tests_by_model.get(model):
                failed_tests_by_model[model] = []

            failed_tests_by_model[model].append(
                FailedTest(
                    name=name,
                    display_name=display_name,
                    description=description,
                    fieldnames=fieldnames,
                    failed_rows=failed_rows,
                )
            )

    return failed_tests_by_model


def write_output_file(
    output_filepath: str, failed_tests_by_model: FailedTestsByModel
) -> None:
    """Given an output filepath and a dict of model/test-failure pairs,
    generates a zipfile of workbooks, where each workbook represents a model
    with sheets for each of the model's failed tests."""
    output_dirpath = output_filepath.split(".zip")[0]
    os.mkdir(output_dirpath)

    for model_name, failed_tests in failed_tests_by_model.items():
        workbook = FailedTestWorkbook(model_name)
        for idx, failed_test in enumerate(failed_tests):
            workbook.add_sheet(failed_test)
        print(f"Saving workbook for {model_name}")
        workbook.save(output_dirpath)

    shutil.make_archive(output_dirpath, "zip", output_dirpath)
    shutil.rmtree(output_dirpath)


if __name__ == "__main__":
    main()
