#!/usr/bin/env python3
#
# Generates a .zip file containing Excel workbooks of dbt test failures that
# can be shared with other teams for human review.
#
# This script assumes that it is being run in sequence after a call to
# `dbt test --store-failures`, since it depends on two files created by
# that operation (target/run_results.json and target/manifest.json).
#
# Expects three optional positional arguments:
#
#   1. The local path to the run_results.json file generated by a test run
#     i. If not present, defaults to './target/run_results.json'
#   2. The local path to the manifest.json file for the dbt DAG
#     i. If not present, defaults to './target/manifest.json'
#   3. The output path to write the .zip file
#     i. If this argument is missing, the script will default to
#        './test_failures.zip'
#
# Expects one environment variable to be set:
#
#  1.AWS_ATHENA_S3_STAGING_DIR: Location in S3 where Athena query results
#    should be written
#
# Each workbook in the output .zip file represents a view or table in the
# warehouse; each sheet in a workbook represents a failed test; and each row
# in a sheet represents a database row that failed. The resulting directory
# structure looks like this:
#
#   <output_path>/
#         |
#         --- <schema1>/
#         |      |
#         |      --- <view/table1>.xslx
#         |      |
#         |      --- <view/table2>.xlsx
#         |
#         --- <schema2>/
#                |
#                --- <view/table3>.xlsx
#
# Example usage:
#
#   AWS_ATHENA_S3_STAGING_DIR=s3://foo-bar-baz/ \
#       python3 generate_test_failure_workbook_zip.py \
#       ./target/run_results.json \
#       ./target/manifest.json \
#       ./test_failures.zip

import dataclasses
import json
import os
import shutil
import sys
import typing

import openpyxl
import openpyxl.styles
import pyathena


@dataclasses.dataclass
class FailingTest:
    """Struct representing a failed dbt test."""

    name: str
    display_name: typing.Optional[str]
    description: typing.Optional[str]
    fieldnames: typing.List
    failing_rows: typing.Tuple


FailingTestsByModel = typing.Dict[str, typing.List[FailingTest]]


def main() -> None:
    """Entrypoint to this script. Parses input arguments and writes a zipfile
    of test failures to the output path."""
    try:
        run_results_filepath = sys.argv[1]
    except IndexError:
        run_results_filepath = os.path.join("target", "run_results.json")

    try:
        manifest_filepath = sys.argv[2]
    except IndexError:
        manifest_filepath = os.path.join("target", "manifest.json")

    try:
        output_filepath = sys.argv[3]
    except IndexError:
        output_filepath = "test_failures.zip"

    with open(run_results_filepath) as run_results_fobj:
        run_results = json.load(run_results_fobj)

    with open(manifest_filepath) as manifest_fobj:
        manifest = json.load(manifest_fobj)

    failing_tests_by_model = get_failing_tests_by_model(run_results, manifest)
    if not failing_tests_by_model:
        raise ValueError(f"{run_results_filepath} contains no failing rows")

    write_output_file(output_filepath, failing_tests_by_model)


def get_failing_tests_by_model(
    run_results: typing.Dict, manifest: typing.Dict
) -> FailingTestsByModel:
    """Given two artifacts from a `dbt test --store-failures` call (a
    run_results.json file and a manifest.json file), generates a dict
    where each key is a model in the warehouse and each associated value is
    a list of failed tests for that model."""
    conn = pyathena.connect(
        s3_staging_dir=os.getenv("AWS_ATHENA_S3_STAGING_DIR"),
        region_name="us-east-1",
    )
    cursor = conn.cursor()

    failing_tests_by_model: FailingTestsByModel = {}

    for result in run_results["results"]:
        if result["status"] == "fail":
            unique_id = result["unique_id"]
            # Unique ID format is:
            # test.athena.<name>.<hash>
            name = unique_id.split(".")[2]

            node = manifest["nodes"].get(unique_id)
            if node is None:
                raise ValueError(
                    f"Missing dbt manifest node with id {unique_id}"
                )

            meta = node.get("meta", {})
            display_name = meta.get("display_name")
            description = meta.get("description")

            models = node.get("depends_on", {}).get("nodes", [])
            if not models:
                breakpoint()
                raise ValueError(
                    f"Missing depends_on.nodes attribute for test {name}"
                )
            model = models[0]

            relation_name = node.get("relation_name")
            if relation_name is None:
                raise ValueError(
                    f"Missing relation_name attribute for test {name}. "
                    "Did you run `dbt test` with the --store-failures flag?"
                )

            cursor.execute(f"select * from {relation_name}")
            # The first element of each tuple in the list produced by
            # cursor.description is always the column name
            fieldnames = [col_meta[0] for col_meta in cursor.description]
            failing_rows = cursor.fetchall()
            if len(failing_rows) == 0:
                raise ValueError(
                    f"Test {relation_name} has status 'fail' but no failures"
                )

            if not failing_tests_by_model.get(model):
                failing_tests_by_model[model] = []

            failing_tests_by_model[model].append(
                FailingTest(
                    name=name,
                    display_name=display_name,
                    description=description,
                    fieldnames=fieldnames,
                    failing_rows=failing_rows,
                )
            )

    return failing_tests_by_model


def write_output_file(
    output_filepath: str, failing_tests_by_model: FailingTestsByModel
) -> None:
    """Given an output filepath and a dict of model/test-failure pairs,
    generates a zipfile of workbooks, where each workbook represents a model
    with sheets for each of the model's failing tests."""
    output_dirpath = output_filepath.split(".zip")[0]
    os.mkdir(output_dirpath)

    for model, failing_tests in failing_tests_by_model.items():
        workbook = openpyxl.Workbook()

        # openpyxl workbooks are created with one untitled active sheet by
        # default, so rename and fill out that sheet before creating any
        # new sheets
        first_sheet = workbook.active
        first_failing_test = failing_tests[0]
        add_failing_test_data_to_sheet(first_sheet, first_failing_test)

        # Create sheets for any remaining tests
        for failing_test in failing_tests[1:]:
            sheet = workbook.create_sheet()
            add_failing_test_data_to_sheet(sheet, failing_test)

        # The format for model identifiers is
        # <'source'/'model'>.athena.<schema_name>.<model_name>
        workbook_filename = f"{model.split('athena.')[-1]}.xlsx"
        workbook.save(os.path.join(output_dirpath, workbook_filename))

    shutil.make_archive(output_dirpath, "zip", output_dirpath)
    shutil.rmtree(output_dirpath)


def add_failing_test_data_to_sheet(
    sheet: openpyxl.worksheet.worksheet.Worksheet, failing_test: FailingTest
) -> None:
    """Given an Excel sheet object and a failing dbt test object, add the
    failing test data to the sheet."""
    # `display_name` can be null, so fall back to `name`
    test_name = failing_test.display_name or failing_test.name
    # For maximum compatibility, Excel worksheet names should not exceed
    # 31 characters
    sheet.title = test_name[0:31]

    # We are rolling out test descriptions incrementally, so only add a
    # description row if a description is defined on the test
    header_idx = 1
    if failing_test.description is not None:
        sheet.append([failing_test.description])
        header_idx = 2

    # Style the header differently from rows so that it is visually distinct
    sheet.append(failing_test.fieldnames)
    font = openpyxl.styles.Font(bold=True)
    for cell in sheet[header_idx]:
        cell.font = font

    for failing_row in failing_test.failing_rows:
        sheet.append(failing_row)


if __name__ == "__main__":
    main()
