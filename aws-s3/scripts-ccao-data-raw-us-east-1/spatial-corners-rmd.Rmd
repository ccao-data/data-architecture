---
title: "Damon Corners Working Document"
output: html_document
date: "2023-06-30"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
library(osmdata)
library(tidyverse)
library(sf)
library(ggmap)
library(tidygraph)
library(sfnetworks)
library(dbscan)
library(units)
library(tmap)
library(rgrass)
library(link2GI)
library(nabor)
library(terra)
library(nngeo)
library(geosphere)
library(profvis)
library(furrr)
```



```{r}


township <- "Calumet"

#bbox <- ccao::town_shp %>%
#  filter(township_name == township) %>%
#  st_bbox()

# WORKS FOR -87.625 and doesn't for -87.4

bbox <- st_bbox(c(xmin = -87.625, ymin = 41.642, xmax = -87.61, ymax = 41.65))



# Street network data
osm_data <- function(type) {
  opq(bbox = bbox) %>%
    add_osm_feature(key = "highway", value = type) %>%
    add_osm_feature(key = "highway", value = "!footway") %>%
    add_osm_feature(key = "highway:tag", value = "!alley") %>%
    osmdata_sf()
}

highway_type <- available_tags("highway")

town_osm <- lapply(highway_type, osm_data)

town_osm_center <- town_osm$Value$osm_lines %>%
  filter(!highway %in% c("bridleway", "construction", "corridor", "cycleway", "elevator", "service", "services", "steps"))

plot(town_osm_center[1])


# Construct the street network
network <- as_sfnetwork(town_osm_center, directed = FALSE) %>%
  activate(edges) %>%
  arrange(edge_length()) %>%
  filter(!edge_is_multiple()) %>%
  filter(!edge_is_loop()) %>%
  st_transform(3435) %>%
  convert(to_spatial_simple) %>%
  # convert(to_spatial_smooth) %>%
  convert(to_spatial_subdivision) %>%
  activate(nodes) %>%
  mutate(degree = centrality_degree())



# Parcel data
parcels <- st_read(
  glue::glue(
    "https://datacatalog.cookcountyil.gov/resource/77tz-riq7.geojson?PoliticalTownship=Town%20of%20{township}&$limit=1000000"
  )) %>% 
  mutate(id = row_number())

parcels <- parcels %>%
  filter(latitude >= 41.642 & latitude <= 41.65) %>% 
  filter(longitude <= -87.625 & longitude >= -87.61) 

parcel <- parcels$geometry

```








```{r}


DamonFunction_single_observation_final <- function(parcels, network) {
  # Create a nested list for target parcel, neighbor parcel, neighbor network
  # Find the neighbor parcel clip
  parcels <- parcels %>%
    st_transform(3435) %>%
    mutate(buffer_area = st_buffer(geometry, dist = units::set_units(100, "m"))) %>%
    mutate(clip_parcel = st_intersects(., buffer_area)) %>%
    st_transform(4326)
  
  clip_parcel <- map(parcels$clip_parcel, function(x) {
    st_transform(parcels$geometry[x], 4326)
  })

  # Find the neighbor network clip
  clip_network <- list()
  for (i in 1:nrow(parcels)) {
    clip_network[[i]] <- network %>%
      activate("edges") %>%
      st_filter(parcels$buffer_area[i], .pred = st_overlaps) %>%
      activate("nodes") %>%
      filter(!node_is_isolated()) %>%
      activate("edges") %>%
      st_as_sf() %>%
      st_transform(4326)
  }
  
  
  # Step 1: Create the minimum rectangle
  min_rectangle <- st_minimum_rotated_rectangle(parcel)
  min_rectangle_line <- st_segments(min_rectangle) %>%
    st_transform(crs = 4326)
  
  # Step 2: Draw the cross
  ## Find out the bearing angle
  rectangle_network <- as_sfnetwork(min_rectangle_line, directed = FALSE) %>%
    activate(edges) %>%
    mutate(bearing = edge_azimuth()) %>%
    mutate(bearing = units::set_units(bearing, "degree")) %>%
    mutate(id = row_number()) %>%
    mutate(corrected_bearing = ifelse(id %% 4 != 0, bearing, bearing + units::set_units(180, "degree"))) %>%
    st_as_sf()
  
  ## Step 3 Find out the distance
  rectangle_network <- rectangle_network %>%
    mutate(length = st_length(x) + units::set_units(10, "m"))
  
  ## Step 4 Find out the starting point
  centroid <- st_centroid(parcel) %>% st_as_sf()
  centroid <- centroid %>%
    slice(rep(1:n(), each = 4)) %>%
    st_transform(crs = 4326) %>%
    st_coordinates()
  
   # Step 5: Remove the cross segments in the intersection of {cross_touching_unit & neighbor_unit}
  
  cross_int <- suppressMessages(imap_lgl(neighbor_and_touching, function(x, i) {
    any(map_lgl(x, function(y) {
      as.logical(st_intersects(cross$geom[i], neighbor_parcel[y]))
    }))
  }))
  
  cross_filter <- cross %>%
    mutate(is_neighboring = cross_int) %>%
    mutate(id = 1:4) %>%
    filter(!is_neighboring)
  
  # Step 6: Calculate the angle of cross segments
  angle_diff <- function(theta1, theta2) {
    theta <- abs(theta1 - theta2) %% 360
    return(ifelse(theta > 180, 360 - theta, theta))
  }
  
  cross_corner <- rectangle_network %>%
    mutate(bearing = as.numeric(bearing)) %>%
    filter(id %in% cross_filter$id) %>%
    mutate(diff_degree = angle_diff(bearing, lag(bearing))) %>%
    filter(diff_degree >= 85 & diff_degree <= 95, na.rm = TRUE)
  
 

 # Find out all the units touched by the cross
  touching_unit <- suppressWarnings(suppressMessages(st_intersects(cross$geom, neighbor_parcel)))
  
  # Step 3: Find out all the neighbor units for a parcel
  neighbor_unit <- suppressWarnings(suppressMessages(st_touches(parcel, neighbor_parcel)))
  neighbor_unit <- rep(neighbor_unit, each = 4)
  
  # Step 4: Find out the intersection of {cross_touching_unit & neighbor_unit}
  neighbor_and_touching <- list()
  for (i in 1:4) {
    neighbor_and_touching[[i]] <- intersect(touching_unit[[i]], neighbor_unit[[i]])
  }
  
  # Step 5: Remove the cross segments in the intersection of {cross_touching_unit & neighbor_unit}
  
  cross_int <- suppressMessages(imap_lgl(neighbor_and_touching, function(x, i) {
    any(map_lgl(x, function(y) {
      as.logical(st_intersects(cross$geom[i], neighbor_parcel[y]))
    }))
  }))
  
  cross_filter <- cross %>%
    mutate(is_neighboring = cross_int) %>%
    mutate(id = 1:4) %>%
    filter(!is_neighboring)
  
  # Step 6: Calculate the angle of cross segments
  angle_diff <- function(theta1, theta2) {
    theta <- abs(theta1 - theta2) %% 360
    return(ifelse(theta > 180, 360 - theta, theta))
  }
  
  cross_corner <- rectangle_network %>%
    mutate(bearing = as.numeric(bearing)) %>%
    filter(id %in% cross_filter$id) %>%
    mutate(diff_degree = angle_diff(bearing, lag(bearing))) %>%
    filter(diff_degree >= 85 & diff_degree <= 95, na.rm = TRUE)
  
  touching_unit_street <- suppressWarnings(suppressMessages(st_intersects(cross$geom, network)))
  touching_street_number <- sum(lengths(touching_unit_street))
  
  cross_corner_number <- nrow(cross_corner)
  
  aspect_ratio <- max(cross$aspect_ratio, na.rm = TRUE)
  
  
  if (all(touching_street_number >= 2) & all(cross_corner_number >= 1) & all(aspect_ratio < 30)) {
    return(TRUE)
  } else {
    return(FALSE)
  }

}
TempFilea <- vector("list", nrow(parcels))

for (i in 1:nrow(parcels)) {
  TempFilea[[i]] <- DamonFunction_single_observation_final(parcels[i, ], network)
}


for (i in 1:nrow(parcels)) {
  cross_idx <- (i - (i %% 4) + 1):(i - (i %% 4) + 4)
  TempFilea[[i]] <-  DamonFunction_single_observation_final(parcels[i, ], network)
}



```









```{r}

### THIS RUNS AND CREATES ALL NECESSARY INTERMEDIATE OUTPUTS DO NOT CHANGE UNTIL LATER

DamonFunction_single_observation <- function(parcels, network) {
  # Create a nested list for target parcel, neighbor parcel, neighbor network
  # Find the neighbor parcel clip
  parcels <- parcels %>%
    st_transform(3435) %>%
    mutate(buffer_area = st_buffer(geometry, dist = units::set_units(100, "m"))) %>%
    mutate(clip_parcel = st_intersects(., buffer_area)) %>%
    st_transform(4326)
  
  clip_parcel <- map(parcels$clip_parcel, function(x) {
    st_transform(parcels$geometry[x], 4326)
  })

  # Find the neighbor network clip
  clip_network <- list()
  for (i in 1:nrow(parcels)) {
    clip_network[[i]] <- network %>%
      activate("edges") %>%
      st_filter(parcels$buffer_area[i], .pred = st_overlaps) %>%
      activate("nodes") %>%
      filter(!node_is_isolated()) %>%
      activate("edges") %>%
      st_as_sf() %>%
      st_transform(4326)
  }
  
  
  
  # Step 1: Create the minimum rectangle
  min_rectangle <- st_minimum_rotated_rectangle(parcel)
  min_rectangle_line <- st_segments(min_rectangle) %>%
    st_transform(crs = 4326)
  
  # Step 2: Draw the cross
  ## Find out the bearing angle
  rectangle_network <- as_sfnetwork(min_rectangle_line, directed = FALSE) %>%
    activate(edges) %>%
    mutate(bearing = edge_azimuth()) %>%
    mutate(bearing = units::set_units(bearing, "degree")) %>%
    mutate(id = row_number()) %>%
    mutate(corrected_bearing = ifelse(id %% 4 != 0, bearing, bearing + units::set_units(180, "degree"))) %>%
    st_as_sf()
  
  ## Step 3 Find out the distance
  rectangle_network <- rectangle_network %>%
    mutate(length = st_length(x) + units::set_units(10, "m"))
  
  ## Step 4 Find out the starting point
  centroid <- st_centroid(parcel) %>% st_as_sf()
  centroid <- centroid %>%
    slice(rep(1:n(), each = 4)) %>%
    st_transform(crs = 4326) %>%
    st_coordinates()
  
  ## Step 5 Draw the cross
  dest <- destPoint(p = centroid, b = rectangle_network$corrected_bearing, d = rectangle_network$length)
  
  cross <- cbind(centroid, dest) %>% as.data.frame()
  
  ## Step 6 Draw Line
  draw_line <- function(r) {
    st_linestring(t(matrix(unlist(r), 2, 2)))
  }
  
  ## Step 7 Cross Function
  cross$geom <- st_sfc(sapply(1:nrow(cross), function(i) {
    draw_line(cross[i, ])
  }, simplify = FALSE))
  
  cross <- cross %>%
    st_set_geometry("geom") %>%
    st_set_crs(4326) %>%
    mutate(
      length = st_length(geom),
      aspect_ratio = as.numeric(lag(length) / length),
      id = rep(1:(nrow(.) / 4), each = 4)
    ) 
  

  return(list(rectangle_network = rectangle_network, cross_lst = split(cross, cross$id), clip_network = clip_network, clip_parcel = clip_parcel))
}


TempFile <- vector("list", nrow(parcels))

for (i in 1:nrow(parcels)) {
  TempFile[[i]] <- DamonFunction_single_observation(parcels[i, ], network)
}





```


```{r}


result <- DamonFunction1(parcels, network)
rectangle_network <- result$rectangle_network
cross_lst <- result$cross_lst
clip_network <- result$clip_network
clip_parcel <- result$clip_parcel



```





```{r}



# Create the function 
crossing <- function(parcel, cross, network, neighbor_parcel, rectangle_network) {
  
  # Find out all the units touched by the cross
  touching_unit <- suppressWarnings(suppressMessages(st_intersects(cross$geom, neighbor_parcel)))
  
  # Step 3: Find out all the neighbor units for a parcel
  neighbor_unit <- suppressWarnings(suppressMessages(st_touches(parcel, neighbor_parcel)))
  neighbor_unit <- rep(neighbor_unit, each = 4)
  
  
  # Step 4: Find out the intersection of {cross_touching_unit & neighbor_unit}
  neighbor_and_touching <- list()
  for (i in 1:4) {
    neighbor_and_touching[[i]] <- intersect(touching_unit[[i]], neighbor_unit[[i]])
  }
  
  # Step 5: Remove the cross segments in the intersection of {cross_touching_unit & neighbor_unit}
  
  cross_int <- suppressMessages(imap_lgl(neighbor_and_touching, function(x, i) {
    any(map_lgl(x, function(y) {
      as.logical(st_intersects(cross$geom[i], neighbor_parcel[y]))
    }))
  }))
  
  cross_filter <- cross %>%
    mutate(is_neighboring = cross_int) %>%
    mutate(id = 1:4) %>%
    filter(!is_neighboring)
  
  # Step 6: Calculate the angle of cross segments
  angle_diff <- function(theta1, theta2) {
    theta <- abs(theta1 - theta2) %% 360
    return(ifelse(theta > 180, 360 - theta, theta))
  }
  
  cross_corner <- rectangle_network %>%
    mutate(bearing = as.numeric(bearing)) %>%
    filter(id %in% cross_filter$id) %>%
    mutate(diff_degree = angle_diff(bearing, lag(bearing))) %>%
    filter(diff_degree >= 85 & diff_degree <= 95, na.rm = TRUE)
  
  touching_unit_street <- suppressWarnings(suppressMessages(st_intersects(cross$geom, network)))
  touching_street_number <- sum(lengths(touching_unit_street))
  
  cross_corner_number <- nrow(cross_corner)
  
  aspect_ratio <- max(cross$aspect_ratio, na.rm = TRUE)
  
  
  if (all(touching_street_number >= 2) & all(cross_corner_number >= 1) & all(aspect_ratio < 30)) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}
```

































```{r}


DamonFunction1 <- function(parcels, network) {
  # Create a nested list for target parcel, neighbor parcel, neighbor network
  # Find the neighbor parcel clip
  parcels <- parcels %>%
    st_transform(3435) %>%
    mutate(buffer_area = st_buffer(geometry, dist = units::set_units(100, "m"))) %>%
    mutate(clip_parcel = st_intersects(., buffer_area)) %>%
    st_transform(4326)
  
  clip_parcel <- map(parcels$clip_parcel, function(x) {
    st_transform(parcels$geometry[x], 4326)
  })

  # Find the neighbor network clip
  clip_network <- list()
  for (i in 1:nrow(parcels)) {
    clip_network[[i]] <- network %>%
      activate("edges") %>%
      st_filter(parcels$buffer_area[i], .pred = st_overlaps) %>%
      activate("nodes") %>%
      filter(!node_is_isolated()) %>%
      activate("edges") %>%
      st_as_sf() %>%
      st_transform(4326)
  }
  
  
  
  # Step 1: Create the minimum rectangle
  min_rectangle <- st_minimum_rotated_rectangle(parcel)
  min_rectangle_line <- st_segments(min_rectangle) %>%
    st_transform(crs = 4326)
  
  # Step 2: Draw the cross
  ## Find out the bearing angle
  rectangle_network <- as_sfnetwork(min_rectangle_line, directed = FALSE) %>%
    activate(edges) %>%
    mutate(bearing = edge_azimuth()) %>%
    mutate(bearing = units::set_units(bearing, "degree")) %>%
    mutate(id = row_number()) %>%
    mutate(corrected_bearing = ifelse(id %% 4 != 0, bearing, bearing + units::set_units(180, "degree"))) %>%
    st_as_sf()
  
  ## Step 3 Find out the distance
  rectangle_network <- rectangle_network %>%
    mutate(length = st_length(x) + units::set_units(10, "m"))
  
  ## Step 4 Find out the starting point
  centroid <- st_centroid(parcel) %>% st_as_sf()
  centroid <- centroid %>%
    slice(rep(1:n(), each = 4)) %>%
    st_transform(crs = 4326) %>%
    st_coordinates()
  
  ## Step 5 Draw the cross
  dest <- destPoint(p = centroid, b = rectangle_network$corrected_bearing, d = rectangle_network$length)
  
  cross <- cbind(centroid, dest) %>% as.data.frame()
  
  ## Step 6 Draw Line
  draw_line <- function(r) {
    st_linestring(t(matrix(unlist(r), 2, 2)))
  }
  
  ## Step 7 Cross Function
  cross$geom <- st_sfc(sapply(1:nrow(cross), function(i) {
    draw_line(cross[i, ])
  }, simplify = FALSE))
  
  cross <- cross %>%
    st_set_geometry("geom") %>%
    st_set_crs(4326) %>%
    mutate(
      length = st_length(geom),
      aspect_ratio = as.numeric(lag(length) / length),
      id = rep(1:(nrow(.) / 4), each = 4)
    )
  
  # Return the results
  return(list(rectangle_network = rectangle_network, cross_lst = split(cross, cross$id), clip_network = clip_network, clip_parcel = clip_parcel))
}



result <- DamonFunction1(parcels, network)
rectangle_network <- result$rectangle_network
cross_lst <- result$cross_lst
clip_network <- result$clip_network
clip_parcel <- result$clip_parcel



```





```{r}



# Create the function 
crossing <- function(parcel, cross, network, neighbor_parcel, rectangle_network) {
  
  # Find out all the units touched by the cross
  touching_unit <- suppressWarnings(suppressMessages(st_intersects(cross$geom, neighbor_parcel)))
  
  # Step 3: Find out all the neighbor units for a parcel
  neighbor_unit <- suppressWarnings(suppressMessages(st_touches(parcel, neighbor_parcel)))
  neighbor_unit <- rep(neighbor_unit, each = 4)
  
  # Step 4: Find out the intersection of {cross_touching_unit & neighbor_unit}
  neighbor_and_touching <- list()
  for (i in 1:4) {
    neighbor_and_touching[[i]] <- intersect(touching_unit[[i]], neighbor_unit[[i]])
  }
  
  # Step 5: Remove the cross segments in the intersection of {cross_touching_unit & neighbor_unit}
  
  cross_int <- suppressMessages(imap_lgl(neighbor_and_touching, function(x, i) {
    any(map_lgl(x, function(y) {
      as.logical(st_intersects(cross$geom[i], neighbor_parcel[y]))
    }))
  }))
  
  cross_filter <- cross %>%
    mutate(is_neighboring = cross_int) %>%
    mutate(id = 1:4) %>%
    filter(!is_neighboring)
  
  # Step 6: Calculate the angle of cross segments
  angle_diff <- function(theta1, theta2) {
    theta <- abs(theta1 - theta2) %% 360
    return(ifelse(theta > 180, 360 - theta, theta))
  }
  
  cross_corner <- rectangle_network %>%
    mutate(bearing = as.numeric(bearing)) %>%
    filter(id %in% cross_filter$id) %>%
    mutate(diff_degree = angle_diff(bearing, lag(bearing))) %>%
    filter(diff_degree >= 85 & diff_degree <= 95, na.rm = TRUE)
  
  touching_unit_street <- suppressWarnings(suppressMessages(st_intersects(cross$geom, network)))
  touching_street_number <- sum(lengths(touching_unit_street))
  
  cross_corner_number <- nrow(cross_corner)
  
  aspect_ratio <- max(cross$aspect_ratio, na.rm = TRUE)
  
  
  if (all(touching_street_number >= 2) & all(cross_corner_number >= 1) & all(aspect_ratio < 30)) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}
```


```{r}
## SEQUENTIAL
corner_indicator <- c()

for (i in 1:196) {
  cross_idx <- (i - (i %% 4) + 1):(i - (i %% 4) + 4)
  corner_indicator[[i]] <- crossing(parcel[i], cross_lst[[i]], clip_network[[i]], clip_parcel[[i]], rectangle_network)
}
```


```{r}



# crossing <- function(parcel, cross, network, neighbor_parcel, rectangle_network) 
  

corner_parcel_calumet <- parcels %>%
  mutate(corner_indicator = unlist(corner_indicator)) %>%
  filter(corner_indicator == TRUE)

ggplot() +
  geom_sf(data = st_geometry(parcels)) +
  geom_sf(data = st_geometry(corner_parcel_calumet), fill = "blue") +
  geom_sf(data = st_as_sf(network, 'edges'), col = 'green') +
  theme_void()

# write_csv(corner_parcel_calumet, 'corner_calumet_1.csv')


```

